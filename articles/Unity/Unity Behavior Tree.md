## 行为树基础节点

Composite 节点
- parallel: 下面的子节点同时运行
- sequence：依次执行下面的节点
- selector：选择执行下面的节点。例如有左右两个节点，左边的节点如果不成功就执行右边的，如果左边的成功了，那右边的就不会执行

Decorator 节点
- inverter: 取非操作，反转节点的结果
- repeater：重复执行节点，相当于while
- util Fail/Success: 直到节点失败或成功

Action 节点：用于执行一些行为

Condition 节点：用于执行一些条件判断

## 自定义节点

#### Action
继承`Action`，定义Shared变量，在Update中定义行为
``` C#
public override TaskState OnUpdate()
{
	//...
}
```

#### Condition
继承Condition，定义Shared变量, 在OnUpdate中定义行为

最终的结果都是返回Task的状态

## 调试

- 右键任意节点Add BreakPoint
- 在behavior tree顶部窗口有调试按钮，可以选择单步调试，继续，进入节点
- 执行到断点，行为树会暂停，等待行动

## 行为树管理

如果当一个角色拥有非常复杂的行为时，或者行为树逻辑节点很多很杂的情况该如何处理？

答：将一颗大行为树拆成几棵小行为树，利用子树节点对子树进行服用。构建行为模版，把行为逻辑变得通用，例如只有参数不一样的情况下，就开放参数，保持其他逻辑一致，这样可以复用节点。还可以给节点写comment，让其他知道这些节点分别是来做什么的

## 行为树和状态机的区别

- 状态机：状态和转换是强耦合的，公用的逻辑比较难服用，而且随着状态数量增多，转换的逻辑会越来越复杂，可能会遗漏边缘情况
- 行为树：由层次化的节点组成的，节点可以独立分装，甚至共同的逻辑可以封装成子树来实现服用，不用害怕逻辑复杂后状态转换和调试的困难度，因为是树形结构，比状态机更直观

#### 有限状态机升级成行为树

理论上我只要把状态机中的状态逻辑拆分，封装成独立函数进行服用，然后用`if else`来模拟selector就可以升级为行为树，例如：

FSM
```
巡逻 → (发现敌人) → 追击 → (在攻击范围内) → 攻击
  ↑                   ↓                        ↓
  └───(敌人消失)────┘────(敌人超出范围)───┘
```

行为树
```
选择器(Root)
├── 序列(攻击状态)
│   ├── 条件(敌人在攻击范围内)
│   └── 动作(执行攻击)
├── 序列(追击状态)
│   ├── 条件(发现敌人 AND 不在攻击范围)
│   └── 动作(向敌人移动)
└── 序列(巡逻状态)
    ├── 条件(没有发现敌人) [如为最后一个选项可省略]
    └── 动作(执行巡逻路径)
```